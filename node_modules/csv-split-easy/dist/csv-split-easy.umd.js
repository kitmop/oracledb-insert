"use strict";/**
 * @name csv-split-easy
 * @fileoverview Splits the CSV string into array of arrays, each representing a row of columns
 * @version 6.0.20
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/csv-split-easy/}
 */

var csvSplitEasy=(()=>{var ae=Object.create;var b=Object.defineProperty;var le=Object.getOwnPropertyDescriptor;var ue=Object.getOwnPropertyNames,R=Object.getOwnPropertySymbols,ge=Object.getPrototypeOf,_=Object.prototype.hasOwnProperty,fe=Object.prototype.propertyIsEnumerable;var S=(e,n,s)=>n in e?b(e,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[n]=s,y=(e,n)=>{for(var s in n||(n={}))_.call(n,s)&&S(e,s,n[s]);if(R)for(var s of R(n))fe.call(n,s)&&S(e,s,n[s]);return e};var pe=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),ye=(e,n)=>{for(var s in n)b(e,s,{get:n[s],enumerable:!0})},F=(e,n,s,o)=>{if(n&&typeof n=="object"||typeof n=="function")for(let l of ue(n))!_.call(e,l)&&l!==s&&b(e,l,{get:()=>n[l],enumerable:!(o=le(n,l))||o.enumerable});return e};var me=(e,n,s)=>(s=e!=null?ae(ge(e)):{},F(n||!e||!e.__esModule?b(s,"default",{value:e,enumerable:!0}):s,e)),he=e=>F(b({},"__esModule",{value:!0}),e);var O=(e,n,s)=>(S(e,typeof n!="symbol"?n+"":n,s),s);var re=pe((pr,ee)=>{var ve=1/0,Se="[object Symbol]",Oe=/^\s+|\s+$/g,I="\\ud800-\\udfff",U="\\u0300-\\u036f\\ufe20-\\ufe23",K="\\u20d0-\\u20f0",B="\\ufe0e\\ufe0f",$e="["+I+"]",A="["+U+K+"]",E="\\ud83c[\\udffb-\\udfff]",Ne="(?:"+A+"|"+E+")",L="[^"+I+"]",V="(?:\\ud83c[\\udde6-\\uddff]){2}",z="[\\ud800-\\udbff][\\udc00-\\udfff]",G="\\u200d",Y=Ne+"?",Z="["+B+"]?",Ae="(?:"+G+"(?:"+[L,V,z].join("|")+")"+Z+Y+")*",Ee=Z+Y+Ae,Ie="(?:"+[L+A+"?",A,V,z,$e].join("|")+")",Re=RegExp(E+"(?="+E+")|"+Ie+Ee,"g"),_e=RegExp("["+G+I+U+K+B+"]"),Fe=typeof global=="object"&&global&&global.Object===Object&&global,je=typeof self=="object"&&self&&self.Object===Object&&self,xe=Fe||je||Function("return this")();function De(e){return e.split("")}function We(e,n,s,o){for(var l=e.length,r=s+(o?1:-1);o?r--:++r<l;)if(n(e[r],r,e))return r;return-1}function Q(e,n,s){if(n!==n)return We(e,He,s);for(var o=s-1,l=e.length;++o<l;)if(e[o]===n)return o;return-1}function He(e){return e!==e}function Je(e,n){for(var s=-1,o=e.length;++s<o&&Q(n,e[s],0)>-1;);return s}function ke(e,n){for(var s=e.length;s--&&Q(n,e[s],0)>-1;);return s}function qe(e){return _e.test(e)}function q(e){return qe(e)?Me(e):De(e)}function Me(e){return e.match(Re)||[]}var Ce=Object.prototype,Pe=Ce.toString,M=xe.Symbol,C=M?M.prototype:void 0,P=C?C.toString:void 0;function Ue(e,n,s){var o=-1,l=e.length;n<0&&(n=-n>l?0:l+n),s=s>l?l:s,s<0&&(s+=l),l=n>s?0:s-n>>>0,n>>>=0;for(var r=Array(l);++o<l;)r[o]=e[o+n];return r}function X(e){if(typeof e=="string")return e;if(Le(e))return P?P.call(e):"";var n=e+"";return n=="0"&&1/e==-ve?"-0":n}function Ke(e,n,s){var o=e.length;return s=s===void 0?o:s,!n&&s>=o?e:Ue(e,n,s)}function Be(e){return!!e&&typeof e=="object"}function Le(e){return typeof e=="symbol"||Be(e)&&Pe.call(e)==Se}function Ve(e){return e==null?"":X(e)}function ze(e,n,s){if(e=Ve(e),e&&(s||n===void 0))return e.replace(Oe,"");if(!e||!(n=X(n)))return e;var o=q(e),l=q(n),r=Je(o,l),u=ke(o,l)+1;return Ke(o,r,u).join("")}ee.exports=ze});var Xe={};ye(Xe,{defaults:()=>se,splitEasy:()=>Qe,version:()=>Ze});var ce={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function $(e,n){if(!Array.isArray(e)||!e.length)return e;let s=y(y({},ce),n),o,l;if(s.strictlyTwoElementsInRangeArrays&&!e.every((a,i)=>!Array.isArray(a)||a.length!==2?(o=i,l=a.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${o}th range (${JSON.stringify(e[o],null,4)}) has not two but ${l} elements!`);if(!e.every((a,i)=>!Array.isArray(a)||!Number.isInteger(a[0])||a[0]<0||!Number.isInteger(a[1])||a[1]<0?(o=i,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${o}th range (${JSON.stringify(e[o],null,4)}) does not consist of only natural numbers!`);let r=e.length**2,u=0;return Array.from(e).sort((a,i)=>(s.progressFn&&(u+=1,s.progressFn(Math.floor(u*100/r))),a[0]===i[0]?a[1]<i[1]?-1:a[1]>i[1]?1:0:a[0]<i[0]?-1:1))}var j={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function x(e,n){function s(t){return!!t&&typeof t=="object"&&!Array.isArray(t)}if(!Array.isArray(e)||!e.length)return null;let o;if(n)if(s(n)){if(o=y(y({},j),n),o.progressFn&&s(o.progressFn)&&!Object.keys(o.progressFn).length)o.progressFn=null;else if(o.progressFn&&typeof o.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof o.progressFn}", equal to ${JSON.stringify(o.progressFn,null,4)}`);if(![1,2,"1","2"].includes(o.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof o.mergeType}", equal to ${JSON.stringify(o.mergeType,null,4)}`);if(typeof o.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof o.joinRangesThatTouchEdges}", equal to ${JSON.stringify(o.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(n,null,4)} (type ${typeof n})`);else o=y({},j);let l=e.filter(t=>Array.isArray(t)).map(t=>[...t]).filter(t=>t[2]!==void 0||t[0]!==t[1]),r,u,a;o.progressFn?r=$(l,{progressFn:t=>{a=Math.floor(t/5),a!==u&&(u=a,o.progressFn(a))}}):r=$(l);let i=r.length-1;for(let t=i;t>0;t--)o.progressFn&&(a=Math.floor((1-t/i)*78)+21,a!==u&&a>u&&(u=a,o.progressFn(a))),(r[t][0]<=r[t-1][0]||!o.joinRangesThatTouchEdges&&r[t][0]<r[t-1][1]||o.joinRangesThatTouchEdges&&r[t][0]<=r[t-1][1])&&(r[t-1][0]=Math.min(r[t][0],r[t-1][0]),r[t-1][1]=Math.max(r[t][1],r[t-1][1]),r[t][2]!==void 0&&(r[t-1][0]>=r[t][0]||r[t-1][1]<=r[t][1])&&r[t-1][2]!==null&&(r[t][2]===null&&r[t-1][2]!==null?r[t-1][2]=null:r[t-1][2]!=null?+o.mergeType==2&&r[t-1][0]===r[t][0]?r[t-1][2]=r[t][2]:r[t-1][2]+=r[t][2]:r[t-1][2]=r[t][2]),r.splice(t,1),t=r.length);return r.length?r:null}var de=!0,N="Invariant failed";function D(e,n){if(!e){if(de)throw new Error(N);var s=typeof n=="function"?n():n,o=s?N+": "+s:N;throw new Error(o)}}function W(e,n,s){let o=0,l=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof e!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(n&&!Array.isArray(n))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof n}, equal to: ${JSON.stringify(n,null,4)}`);if(s&&typeof s!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof s}, equal to: ${JSON.stringify(s,null,4)}`);if(!n||!n.filter(g=>g).length)return e;let r;Array.isArray(n)&&Number.isInteger(n[0])&&Number.isInteger(n[1])?r=[Array.from(n)]:r=Array.from(n);let u=r.length,a=0;r.filter(g=>g).forEach((g,f)=>{if(s&&(o=Math.floor(a/u*10),o!==l&&(l=o,s(o))),!Array.isArray(g))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${f}th element not an array: ${JSON.stringify(g,null,4)}, which is ${typeof g}`);if(!Number.isInteger(g[0])){if(!Number.isInteger(+g[0])||+g[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${f}th element, array ${JSON.stringify(g,null,0)}. Its first element is not an integer, string index, but ${typeof g[0]}, equal to: ${JSON.stringify(g[0],null,4)}.`);r[f][0]=+r[f][0]}if(!Number.isInteger(g[1])){if(!Number.isInteger(+g[1])||+g[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${f}th element, array ${JSON.stringify(g,null,0)}. Its second element is not an integer, string index, but ${typeof g[1]}, equal to: ${JSON.stringify(g[1],null,4)}.`);r[f][1]=+r[f][1]}a+=1});let i=x(r,{progressFn:g=>{s&&(o=10+Math.floor(g/10),o!==l&&(l=o,s(o)))}});D(i);let t=i.length;if(t>0){let g=e.slice(i[t-1][1]);e=i.reduce((f,m,p,d)=>{s&&(o=20+Math.floor(p/t*80),o!==l&&(l=o,s(o)));let oe=p===0?0:d[p-1][1],ie=d[p][0];return`${f}${e.slice(oe,ie)}${d[p][2]||""}`},""),e+=g}return e}function v(e,n=1){let s="\xA0";function o(r){return Array.from(r).reverse().join("")}function l(r,u,a){let i=a?`
`:"\r",t=a?"\r":`
`;if(!r)return r;let g=0,f=0,m="";for(let p=0,d=r.length;p<d;p++)(r[p]===i||r[p]===t&&r[p-1]!==i)&&f++,`\r
`.includes(r[p])||r[p]===s?(g=0,r[p]===s?m+=r[p]:r[p]===i?f<=u&&(m+=r[p],r[p+1]===t&&(m+=r[p+1],p++)):r[p]===t&&(!r[p-1]||r[p-1]!==i)&&f<=u&&(m+=r[p])):(g++,!r[p+1]&&!f&&(m+=" "));return m}if(typeof e=="string"&&e.length){let r=1;typeof+n=="number"&&Number.isInteger(+n)&&+n>=0&&(r=+n);let u="",a="";if(!e.trim())u=e;else if(!e[0].trim()){for(let i=0,t=e.length;i<t;i++)if(e[i].trim()){u=e.slice(0,i);break}}if(e.trim()&&(e.slice(-1).trim()===""||e.slice(-1)===s)){for(let i=e.length;i--;)if(e[i].trim()){a=e.slice(i+1);break}}return`${l(u,r,!1)}${e.trim()}${o(l(o(a),r,!0))}`}return e}var be={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function H(e,n){if(!Array.isArray(e)||!e.length)return e;let s=y(y({},be),n),o,l;if(s.strictlyTwoElementsInRangeArrays&&!e.every((a,i)=>!Array.isArray(a)||a.length!==2?(o=i,l=a.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${o}th range (${JSON.stringify(e[o],null,4)}) has not two but ${l} elements!`);if(!e.every((a,i)=>!Array.isArray(a)||!Number.isInteger(a[0])||a[0]<0||!Number.isInteger(a[1])||a[1]<0?(o=i,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${o}th range (${JSON.stringify(e[o],null,4)}) does not consist of only natural numbers!`);let r=e.length**2,u=0;return Array.from(e).sort((a,i)=>(s.progressFn&&(u+=1,s.progressFn(Math.floor(u*100/r))),a[0]===i[0]?a[1]<i[1]?-1:a[1]>i[1]?1:0:a[0]<i[0]?-1:1))}var J={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function Te(e,n){function s(t){return!!t&&typeof t=="object"&&!Array.isArray(t)}if(!Array.isArray(e)||!e.length)return null;let o;if(n)if(s(n)){if(o=y(y({},J),n),o.progressFn&&s(o.progressFn)&&!Object.keys(o.progressFn).length)o.progressFn=null;else if(o.progressFn&&typeof o.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] resolvedOpts.progressFn must be a function! It was given of a type: "${typeof o.progressFn}", equal to ${JSON.stringify(o.progressFn,null,4)}`);if(![1,2,"1","2"].includes(o.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] resolvedOpts.mergeType was customised to a wrong thing! It was given of a type: "${typeof o.mergeType}", equal to ${JSON.stringify(o.mergeType,null,4)}`);if(typeof o.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] resolvedOpts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof o.joinRangesThatTouchEdges}", equal to ${JSON.stringify(o.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(n,null,4)} (type ${typeof n})`);else o=y({},J);let l=e.filter(t=>Array.isArray(t)).map(t=>[...t]).filter(t=>t[2]!==void 0||t[0]!==t[1]),r,u,a;o.progressFn?r=H(l,{progressFn:t=>{a=Math.floor(t/5),a!==u&&(u=a,o.progressFn(a))}}):r=H(l);let i=r.length-1;for(let t=i;t>0;t--)o.progressFn&&(a=Math.floor((1-t/i)*78)+21,a!==u&&a>u&&(u=a,o.progressFn(a))),(r[t][0]<=r[t-1][0]||!o.joinRangesThatTouchEdges&&r[t][0]<r[t-1][1]||o.joinRangesThatTouchEdges&&r[t][0]<=r[t-1][1])&&(r[t-1][0]=Math.min(r[t][0],r[t-1][0]),r[t-1][1]=Math.max(r[t][1],r[t-1][1]),r[t][2]!==void 0&&(r[t-1][0]>=r[t][0]||r[t-1][1]<=r[t][1])&&r[t-1][2]!==null&&(r[t][2]===null&&r[t-1][2]!==null?r[t-1][2]=null:r[t-1][2]!=null?+o.mergeType==2&&r[t-1][0]===r[t][0]?r[t-1][2]=r[t][2]:r[t-1][2]+=r[t][2]:r[t-1][2]=r[t][2]),r.splice(t,1),t=r.length);return r.length?r:null}function h(e){return e!=null}function c(e){return Number.isInteger(e)&&e>=0}function T(e){return typeof e=="string"}var we={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},k=class{constructor(e){O(this,"ranges");O(this,"opts");let n=y(y({},we),e);if(n.mergeType&&n.mergeType!==1&&n.mergeType!==2)if(T(n.mergeType)&&n.mergeType.trim()==="1")n.mergeType=1;else if(T(n.mergeType)&&n.mergeType.trim()==="2")n.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof n.mergeType}", equal to ${JSON.stringify(n.mergeType,null,4)}`);this.opts=n,this.ranges=[]}add(e,n,s){if(e==null&&n==null)return;if(h(e)&&!h(n)){if(Array.isArray(e)){if(e.length){if(e.some(r=>Array.isArray(r))){e.forEach(r=>{Array.isArray(r)&&this.add(...r)});return}e.length&&c(+e[0])&&c(+e[1])&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(n,null,0)})`)}else if(!h(e)&&h(n))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(n,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);let o=+e,l=+n;if(c(s)&&(s=String(s)),c(o)&&c(l)){if(h(s)&&!T(s)&&!c(s))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof s}, equal to:
${JSON.stringify(s,null,4)}`);if(h(this.ranges)&&Array.isArray(this.last())&&o===this.last()[1]){if(this.last()[1]=l,this.last()[2],this.last()[2]!==null&&h(s)){let r=this.last()[2]&&this.last()[2].length&&(!this.opts||!this.opts.mergeType||this.opts.mergeType===1)?`${this.last()[2]}${s}`:s;this.opts.limitToBeAddedWhitespace&&(r=v(r,this.opts.limitLinebreaksCount)),T(r)&&!r.length||(this.last()[2]=r)}}else{this.ranges||(this.ranges=[]);let r=s!==void 0&&!(T(s)&&!s.length)?[o,l,s&&this.opts.limitToBeAddedWhitespace?v(s,this.opts.limitLinebreaksCount):s]:[o,l];this.ranges.push(r)}}else throw c(o)&&o>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof l}" equal to: ${JSON.stringify(l,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof o}" equal to: ${JSON.stringify(o,null,4)}`)}push(e,n,s){this.add(e,n,s)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=Te(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>h(e[2])?[e[0],e[1],v(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&c(e[0][0]))this.ranges=Array.from(e);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};var te=me(re(),1);var Ge={removeThousandSeparatorsFromNumbers:!0,padSingleDecimalPlaceNumbers:!0,forceUKStyle:!1};function w(e,n){let s=!0,o=[".",",","'"," "],l;if(typeof e!="string")throw new TypeError(`string-remove-thousand-separators/remSep(): [THROW_ID_01] Input must be string! Currently it's: ${typeof e}, equal to:
${JSON.stringify(e,null,4)}`);if(n&&typeof n!="object")throw new TypeError(`string-remove-thousand-separators/remSep(): [THROW_ID_02] Options object must be a plain object! Currently it's: ${typeof n}, equal to:
${JSON.stringify(n,null,4)}`);let r=y(y({},Ge),n),u=(0,te.default)(e.trim(),'"');if(u==="")return u;if(+e>0&&+e<1)return e;let a=new k;for(let i=0,t=u.length;i<t;i++){if(r.removeThousandSeparatorsFromNumbers&&u[i].trim()===""&&a.add(i,i+1),r.removeThousandSeparatorsFromNumbers&&u[i]==="'"&&(a.add(i,i+1),u[i+1]==="'")){s=!1;break}if(o.includes(u[i])){if(u[i+1]!==void 0&&/^\d$/.test(u[i+1]))if(u[i+2]!==void 0)if(/^\d$/.test(u[i+2]))if(u[i+3]!==void 0)if(/^\d$/.test(u[i+3])){if(u[i+4]!==void 0&&/^\d$/.test(u[i+4])){s=!1;break}else if(r.removeThousandSeparatorsFromNumbers&&a.add(i,i+1),!l)l=u[i];else if(u[i]!==l){s=!1;break}}else{s=!1;break}else r.removeThousandSeparatorsFromNumbers&&r.forceUKStyle&&u[i]===","&&a.add(i,i+1,".");else{s=!1;break}else r.forceUKStyle&&u[i]===","&&a.add(i,i+1,"."),r.padSingleDecimalPlaceNumbers&&a.add(i+2,i+2,"0")}else if(!/^\d$/.test(u[i])){s=!1;break}}return s&&a.current()?W(u,a.current()):u}var ne="6.0.20";var Ze=ne,se={removeThousandSeparatorsFromNumbers:!0,padSingleDecimalPlaceNumbers:!0,forceUKStyle:!1};function Qe(e,n){let s=0,o=0,l=[],r=[],u=!1,a=!0;if(n&&typeof n!="object")throw new Error(`csv-split-easy/split(): [THROW_ID_02] Options object must be a plain object! Currently it's of a type ${typeof n} equal to:
${JSON.stringify(n,null,4)}`);let i=y(y({},se),n);if(typeof e!="string")throw new TypeError(`csv-split-easy/split(): [THROW_ID_04] input must be string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(e==="")return[[""]];e=e.trim();for(let t=0,g=e.length;t<g;t++){if(a&&e[t]!=='"'&&e[t]!==","&&e[t].trim()!==""&&(a=!1),e[t]==='"')if(u&&e[t+1]==='"')t+=1;else if(u){u=!1;let f=e.slice(s,t);f.trim()!==""&&(a=!1);let m=/""/.test(f)?f.replace(/""/g,'"'):w(f,{removeThousandSeparatorsFromNumbers:i.removeThousandSeparatorsFromNumbers,padSingleDecimalPlaceNumbers:i.padSingleDecimalPlaceNumbers,forceUKStyle:i.forceUKStyle});l.push(m)}else u=!0,s=t+1;else if(!u&&e[t]===","){if(e[t-1]!=='"'&&!u){let f=e.slice(s,t);f.trim()!==""&&(a=!1),l.push(w(f,{removeThousandSeparatorsFromNumbers:i.removeThousandSeparatorsFromNumbers,padSingleDecimalPlaceNumbers:i.padSingleDecimalPlaceNumbers,forceUKStyle:i.forceUKStyle}))}s=t+1,o&&(o=0)}else if(e[t]===`
`||e[t]==="\r"){if(!o){if(o=t,!u&&e[t-1]!=='"'){let f=e.slice(s,t);f.trim()!==""&&(a=!1),l.push(w(f,{removeThousandSeparatorsFromNumbers:i.removeThousandSeparatorsFromNumbers,padSingleDecimalPlaceNumbers:i.padSingleDecimalPlaceNumbers,forceUKStyle:i.forceUKStyle}))}a?l.length=0:r.push(l),a=!0,l=[]}s=t+1}else o&&(o=0,s=t);if(t+1===g){if(e[t]!=='"'){let f=e.slice(s,t+1);f.trim()&&(a=!1),l.push(w(f,{removeThousandSeparatorsFromNumbers:i.removeThousandSeparatorsFromNumbers,padSingleDecimalPlaceNumbers:i.padSingleDecimalPlaceNumbers,forceUKStyle:i.forceUKStyle}))}a?l=[]:r.push(l),a=!0}}return r.length===0?[[""]]:r}return he(Xe);})();
/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 6.1.5
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.1.4
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 6.1.4
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.14
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 6.0.15
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
/**
 * @name string-remove-thousand-separators
 * @fileoverview Detects and removes thousand separators (dot/comma/quote/space) from string-type digits
 * @version 6.1.6
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-remove-thousand-separators/}
 */
