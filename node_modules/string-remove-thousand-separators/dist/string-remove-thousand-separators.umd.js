"use strict";/**
 * @name string-remove-thousand-separators
 * @fileoverview Detects and removes thousand separators (dot/comma/quote/space) from string-type digits
 * @version 6.1.6
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-remove-thousand-separators/}
 */

var stringRemoveThousandSeparators=(()=>{var ie=Object.create;var b=Object.defineProperty;var ae=Object.getOwnPropertyDescriptor;var le=Object.getOwnPropertyNames,I=Object.getOwnPropertySymbols,ue=Object.getPrototypeOf,D=Object.prototype.hasOwnProperty,ge=Object.prototype.propertyIsEnumerable;var w=(e,n,o)=>n in e?b(e,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[n]=o,p=(e,n)=>{for(var o in n||(n={}))D.call(n,o)&&w(e,o,n[o]);if(I)for(var o of I(n))ge.call(n,o)&&w(e,o,n[o]);return e};var fe=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),pe=(e,n)=>{for(var o in n)b(e,o,{get:n[o],enumerable:!0})},N=(e,n,o,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let a of le(n))!D.call(e,a)&&a!==o&&b(e,a,{get:()=>n[a],enumerable:!(s=ae(n,a))||s.enumerable});return e};var ye=(e,n,o)=>(o=e!=null?ie(ue(e)):{},N(n||!e||!e.__esModule?b(o,"default",{value:e,enumerable:!0}):o,e)),he=e=>N(b({},"__esModule",{value:!0}),e);var v=(e,n,o)=>(w(e,typeof n!="symbol"?n+"":n,o),o);var ee=fe((gr,X)=>{var Te=1/0,we="[object Symbol]",ve=/^\s+|\s+$/g,R="\\ud800-\\udfff",C="\\u0300-\\u036f\\ufe20-\\ufe23",K="\\u20d0-\\u20f0",U="\\ufe0e\\ufe0f",Oe="["+R+"]",E="["+C+K+"]",S="\\ud83c[\\udffb-\\udfff]",Ae="(?:"+E+"|"+S+")",P="[^"+R+"]",L="(?:\\ud83c[\\udde6-\\uddff]){2}",B="[\\ud800-\\udbff][\\udc00-\\udfff]",z="\\u200d",G=Ae+"?",Y="["+U+"]?",Ee="(?:"+z+"(?:"+[P,L,B].join("|")+")"+Y+G+")*",Se=Y+G+Ee,Re="(?:"+[P+E+"?",E,L,B,Oe].join("|")+")",Ie=RegExp(S+"(?="+S+")|"+Re+Se,"g"),De=RegExp("["+z+R+C+K+U+"]"),Ne=typeof global=="object"&&global&&global.Object===Object&&global,_e=typeof self=="object"&&self&&self.Object===Object&&self,je=Ne||_e||Function("return this")();function Fe(e){return e.split("")}function xe(e,n,o,s){for(var a=e.length,r=o+(s?1:-1);s?r--:++r<a;)if(n(e[r],r,e))return r;return-1}function Z(e,n,o){if(n!==n)return xe(e,We,o);for(var s=o-1,a=e.length;++s<a;)if(e[s]===n)return s;return-1}function We(e){return e!==e}function Je(e,n){for(var o=-1,s=e.length;++o<s&&Z(n,e[o],0)>-1;);return o}function He(e,n){for(var o=e.length;o--&&Z(n,e[o],0)>-1;);return o}function ke(e){return De.test(e)}function k(e){return ke(e)?Me(e):Fe(e)}function Me(e){return e.match(Ie)||[]}var qe=Object.prototype,Ve=qe.toString,M=je.Symbol,q=M?M.prototype:void 0,V=q?q.toString:void 0;function Ce(e,n,o){var s=-1,a=e.length;n<0&&(n=-n>a?0:a+n),o=o>a?a:o,o<0&&(o+=a),a=n>o?0:o-n>>>0,n>>>=0;for(var r=Array(a);++s<a;)r[s]=e[s+n];return r}function Q(e){if(typeof e=="string")return e;if(Pe(e))return V?V.call(e):"";var n=e+"";return n=="0"&&1/e==-Te?"-0":n}function Ke(e,n,o){var s=e.length;return o=o===void 0?s:o,!n&&o>=s?e:Ce(e,n,o)}function Ue(e){return!!e&&typeof e=="object"}function Pe(e){return typeof e=="symbol"||Ue(e)&&Ve.call(e)==we}function Le(e){return e==null?"":Q(e)}function Be(e,n,o){if(e=Le(e),e&&(o||n===void 0))return e.replace(ve,"");if(!e||!(n=Q(n)))return e;var s=k(e),a=k(n),r=Je(s,a),l=He(s,a)+1;return Ke(s,r,l).join("")}X.exports=Be});var Ze={};pe(Ze,{defaults:()=>ne,remSep:()=>Ye,version:()=>Ge});var me={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function O(e,n){if(!Array.isArray(e)||!e.length)return e;let o=p(p({},me),n),s,a;if(o.strictlyTwoElementsInRangeArrays&&!e.every((i,u)=>!Array.isArray(i)||i.length!==2?(s=u,a=i.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) has not two but ${a} elements!`);if(!e.every((i,u)=>!Array.isArray(i)||!Number.isInteger(i[0])||i[0]<0||!Number.isInteger(i[1])||i[1]<0?(s=u,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) does not consist of only natural numbers!`);let r=e.length**2,l=0;return Array.from(e).sort((i,u)=>(o.progressFn&&(l+=1,o.progressFn(Math.floor(l*100/r))),i[0]===u[0]?i[1]<u[1]?-1:i[1]>u[1]?1:0:i[0]<u[0]?-1:1))}var _={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function j(e,n){function o(t){return!!t&&typeof t=="object"&&!Array.isArray(t)}if(!Array.isArray(e)||!e.length)return null;let s;if(n)if(o(n)){if(s=p(p({},_),n),s.progressFn&&o(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&typeof s.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof s.progressFn}", equal to ${JSON.stringify(s.progressFn,null,4)}`);if(![1,2,"1","2"].includes(s.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof s.mergeType}", equal to ${JSON.stringify(s.mergeType,null,4)}`);if(typeof s.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof s.joinRangesThatTouchEdges}", equal to ${JSON.stringify(s.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(n,null,4)} (type ${typeof n})`);else s=p({},_);let a=e.filter(t=>Array.isArray(t)).map(t=>[...t]).filter(t=>t[2]!==void 0||t[0]!==t[1]),r,l,i;s.progressFn?r=O(a,{progressFn:t=>{i=Math.floor(t/5),i!==l&&(l=i,s.progressFn(i))}}):r=O(a);let u=r.length-1;for(let t=u;t>0;t--)s.progressFn&&(i=Math.floor((1-t/u)*78)+21,i!==l&&i>l&&(l=i,s.progressFn(i))),(r[t][0]<=r[t-1][0]||!s.joinRangesThatTouchEdges&&r[t][0]<r[t-1][1]||s.joinRangesThatTouchEdges&&r[t][0]<=r[t-1][1])&&(r[t-1][0]=Math.min(r[t][0],r[t-1][0]),r[t-1][1]=Math.max(r[t][1],r[t-1][1]),r[t][2]!==void 0&&(r[t-1][0]>=r[t][0]||r[t-1][1]<=r[t][1])&&r[t-1][2]!==null&&(r[t][2]===null&&r[t-1][2]!==null?r[t-1][2]=null:r[t-1][2]!=null?+s.mergeType==2&&r[t-1][0]===r[t][0]?r[t-1][2]=r[t][2]:r[t-1][2]+=r[t][2]:r[t-1][2]=r[t][2]),r.splice(t,1),t=r.length);return r.length?r:null}var de=!0,A="Invariant failed";function F(e,n){if(!e){if(de)throw new Error(A);var o=typeof n=="function"?n():n,s=o?A+": "+o:A;throw new Error(s)}}function x(e,n,o){let s=0,a=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof e!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(n&&!Array.isArray(n))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof n}, equal to: ${JSON.stringify(n,null,4)}`);if(o&&typeof o!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof o}, equal to: ${JSON.stringify(o,null,4)}`);if(!n||!n.filter(g=>g).length)return e;let r;Array.isArray(n)&&Number.isInteger(n[0])&&Number.isInteger(n[1])?r=[Array.from(n)]:r=Array.from(n);let l=r.length,i=0;r.filter(g=>g).forEach((g,y)=>{if(o&&(s=Math.floor(i/l*10),s!==a&&(a=s,o(s))),!Array.isArray(g))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${y}th element not an array: ${JSON.stringify(g,null,4)}, which is ${typeof g}`);if(!Number.isInteger(g[0])){if(!Number.isInteger(+g[0])||+g[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${y}th element, array ${JSON.stringify(g,null,0)}. Its first element is not an integer, string index, but ${typeof g[0]}, equal to: ${JSON.stringify(g[0],null,4)}.`);r[y][0]=+r[y][0]}if(!Number.isInteger(g[1])){if(!Number.isInteger(+g[1])||+g[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${y}th element, array ${JSON.stringify(g,null,0)}. Its second element is not an integer, string index, but ${typeof g[1]}, equal to: ${JSON.stringify(g[1],null,4)}.`);r[y][1]=+r[y][1]}i+=1});let u=j(r,{progressFn:g=>{o&&(s=10+Math.floor(g/10),s!==a&&(a=s,o(s)))}});F(u);let t=u.length;if(t>0){let g=e.slice(u[t-1][1]);e=u.reduce((y,d,f,c)=>{o&&(s=20+Math.floor(f/t*80),s!==a&&(a=s,o(s)));let se=f===0?0:c[f-1][1],oe=c[f][0];return`${y}${e.slice(se,oe)}${c[f][2]||""}`},""),e+=g}return e}function T(e,n=1){let o="\xA0";function s(r){return Array.from(r).reverse().join("")}function a(r,l,i){let u=i?`
`:"\r",t=i?"\r":`
`;if(!r)return r;let g=0,y=0,d="";for(let f=0,c=r.length;f<c;f++)(r[f]===u||r[f]===t&&r[f-1]!==u)&&y++,`\r
`.includes(r[f])||r[f]===o?(g=0,r[f]===o?d+=r[f]:r[f]===u?y<=l&&(d+=r[f],r[f+1]===t&&(d+=r[f+1],f++)):r[f]===t&&(!r[f-1]||r[f-1]!==u)&&y<=l&&(d+=r[f])):(g++,!r[f+1]&&!y&&(d+=" "));return d}if(typeof e=="string"&&e.length){let r=1;typeof+n=="number"&&Number.isInteger(+n)&&+n>=0&&(r=+n);let l="",i="";if(!e.trim())l=e;else if(!e[0].trim()){for(let u=0,t=e.length;u<t;u++)if(e[u].trim()){l=e.slice(0,u);break}}if(e.trim()&&(e.slice(-1).trim()===""||e.slice(-1)===o)){for(let u=e.length;u--;)if(e[u].trim()){i=e.slice(u+1);break}}return`${a(l,r,!1)}${e.trim()}${s(a(s(i),r,!0))}`}return e}var ce={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function W(e,n){if(!Array.isArray(e)||!e.length)return e;let o=p(p({},ce),n),s,a;if(o.strictlyTwoElementsInRangeArrays&&!e.every((i,u)=>!Array.isArray(i)||i.length!==2?(s=u,a=i.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) has not two but ${a} elements!`);if(!e.every((i,u)=>!Array.isArray(i)||!Number.isInteger(i[0])||i[0]<0||!Number.isInteger(i[1])||i[1]<0?(s=u,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${s}th range (${JSON.stringify(e[s],null,4)}) does not consist of only natural numbers!`);let r=e.length**2,l=0;return Array.from(e).sort((i,u)=>(o.progressFn&&(l+=1,o.progressFn(Math.floor(l*100/r))),i[0]===u[0]?i[1]<u[1]?-1:i[1]>u[1]?1:0:i[0]<u[0]?-1:1))}var J={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function be(e,n){function o(t){return!!t&&typeof t=="object"&&!Array.isArray(t)}if(!Array.isArray(e)||!e.length)return null;let s;if(n)if(o(n)){if(s=p(p({},J),n),s.progressFn&&o(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&typeof s.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] resolvedOpts.progressFn must be a function! It was given of a type: "${typeof s.progressFn}", equal to ${JSON.stringify(s.progressFn,null,4)}`);if(![1,2,"1","2"].includes(s.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] resolvedOpts.mergeType was customised to a wrong thing! It was given of a type: "${typeof s.mergeType}", equal to ${JSON.stringify(s.mergeType,null,4)}`);if(typeof s.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] resolvedOpts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof s.joinRangesThatTouchEdges}", equal to ${JSON.stringify(s.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(n,null,4)} (type ${typeof n})`);else s=p({},J);let a=e.filter(t=>Array.isArray(t)).map(t=>[...t]).filter(t=>t[2]!==void 0||t[0]!==t[1]),r,l,i;s.progressFn?r=W(a,{progressFn:t=>{i=Math.floor(t/5),i!==l&&(l=i,s.progressFn(i))}}):r=W(a);let u=r.length-1;for(let t=u;t>0;t--)s.progressFn&&(i=Math.floor((1-t/u)*78)+21,i!==l&&i>l&&(l=i,s.progressFn(i))),(r[t][0]<=r[t-1][0]||!s.joinRangesThatTouchEdges&&r[t][0]<r[t-1][1]||s.joinRangesThatTouchEdges&&r[t][0]<=r[t-1][1])&&(r[t-1][0]=Math.min(r[t][0],r[t-1][0]),r[t-1][1]=Math.max(r[t][1],r[t-1][1]),r[t][2]!==void 0&&(r[t-1][0]>=r[t][0]||r[t-1][1]<=r[t][1])&&r[t-1][2]!==null&&(r[t][2]===null&&r[t-1][2]!==null?r[t-1][2]=null:r[t-1][2]!=null?+s.mergeType==2&&r[t-1][0]===r[t][0]?r[t-1][2]=r[t][2]:r[t-1][2]+=r[t][2]:r[t-1][2]=r[t][2]),r.splice(t,1),t=r.length);return r.length?r:null}function h(e){return e!=null}function m(e){return Number.isInteger(e)&&e>=0}function $(e){return typeof e=="string"}var $e={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},H=class{constructor(e){v(this,"ranges");v(this,"opts");let n=p(p({},$e),e);if(n.mergeType&&n.mergeType!==1&&n.mergeType!==2)if($(n.mergeType)&&n.mergeType.trim()==="1")n.mergeType=1;else if($(n.mergeType)&&n.mergeType.trim()==="2")n.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof n.mergeType}", equal to ${JSON.stringify(n.mergeType,null,4)}`);this.opts=n,this.ranges=[]}add(e,n,o){if(e==null&&n==null)return;if(h(e)&&!h(n)){if(Array.isArray(e)){if(e.length){if(e.some(r=>Array.isArray(r))){e.forEach(r=>{Array.isArray(r)&&this.add(...r)});return}e.length&&m(+e[0])&&m(+e[1])&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(n,null,0)})`)}else if(!h(e)&&h(n))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(n,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);let s=+e,a=+n;if(m(o)&&(o=String(o)),m(s)&&m(a)){if(h(o)&&!$(o)&&!m(o))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof o}, equal to:
${JSON.stringify(o,null,4)}`);if(h(this.ranges)&&Array.isArray(this.last())&&s===this.last()[1]){if(this.last()[1]=a,this.last()[2],this.last()[2]!==null&&h(o)){let r=this.last()[2]&&this.last()[2].length&&(!this.opts||!this.opts.mergeType||this.opts.mergeType===1)?`${this.last()[2]}${o}`:o;this.opts.limitToBeAddedWhitespace&&(r=T(r,this.opts.limitLinebreaksCount)),$(r)&&!r.length||(this.last()[2]=r)}}else{this.ranges||(this.ranges=[]);let r=o!==void 0&&!($(o)&&!o.length)?[s,a,o&&this.opts.limitToBeAddedWhitespace?T(o,this.opts.limitLinebreaksCount):o]:[s,a];this.ranges.push(r)}}else throw m(s)&&s>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof a}" equal to: ${JSON.stringify(a,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof s}" equal to: ${JSON.stringify(s,null,4)}`)}push(e,n,o){this.add(e,n,o)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=be(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>h(e[2])?[e[0],e[1],T(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&m(e[0][0]))this.ranges=Array.from(e);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};var te=ye(ee(),1);var re="6.1.6";var Ge=re,ne={removeThousandSeparatorsFromNumbers:!0,padSingleDecimalPlaceNumbers:!0,forceUKStyle:!1};function Ye(e,n){let o=!0,s=[".",",","'"," "],a;if(typeof e!="string")throw new TypeError(`string-remove-thousand-separators/remSep(): [THROW_ID_01] Input must be string! Currently it's: ${typeof e}, equal to:
${JSON.stringify(e,null,4)}`);if(n&&typeof n!="object")throw new TypeError(`string-remove-thousand-separators/remSep(): [THROW_ID_02] Options object must be a plain object! Currently it's: ${typeof n}, equal to:
${JSON.stringify(n,null,4)}`);let r=p(p({},ne),n),l=(0,te.default)(e.trim(),'"');if(l==="")return l;if(+e>0&&+e<1)return e;let i=new H;for(let t=0,g=l.length;t<g;t++){if(r.removeThousandSeparatorsFromNumbers&&l[t].trim()===""&&i.add(t,t+1),r.removeThousandSeparatorsFromNumbers&&l[t]==="'"&&(i.add(t,t+1),l[t+1]==="'")){o=!1;break}if(s.includes(l[t])){if(l[t+1]!==void 0&&/^\d$/.test(l[t+1]))if(l[t+2]!==void 0)if(/^\d$/.test(l[t+2]))if(l[t+3]!==void 0)if(/^\d$/.test(l[t+3])){if(l[t+4]!==void 0&&/^\d$/.test(l[t+4])){o=!1;break}else if(r.removeThousandSeparatorsFromNumbers&&i.add(t,t+1),!a)a=l[t];else if(l[t]!==a){o=!1;break}}else{o=!1;break}else r.removeThousandSeparatorsFromNumbers&&r.forceUKStyle&&l[t]===","&&i.add(t,t+1,".");else{o=!1;break}else r.forceUKStyle&&l[t]===","&&i.add(t,t+1,"."),r.padSingleDecimalPlaceNumbers&&i.add(t+2,t+2,"0")}else if(!/^\d$/.test(l[t])){o=!1;break}}return o&&i.current()?x(l,i.current()):l}return he(Ze);})();
/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 6.1.5
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.1.4
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 6.1.4
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.14
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 6.0.15
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
